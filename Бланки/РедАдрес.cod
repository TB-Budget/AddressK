class inherited                 МашинаРеквизитов.Базовые.редБазовыйДокумент--Базовый.Справочники.редАдрес
                                "Адрес субъекта",
Editor                          Базовый.Справочники.Адрес;
import                          Classes Библио;
import                          Classes HouseCache;
--import XMLRPC Classes Client;
inclass

inobject

  var фреймТипАдреса            : TemplateFrame;
  var фреймСтрокой              : TemplateFrame;
  var фреймГлавное              : TemplateFrame;
  var фреймТипАдреса2           : TemplateFrame;--новый фрейм
  var секПозицииТиповАдресов    : TemplateSection;--новая секция
  var ТипАдресаНаим             : Базовый.Справочники.ТипАдреса[];
  var ТипАдресаПрименен         : logical[];
  var ФИАС: DynamicObject;  --Объект доступа к ФИАС. Зависит от выбранного "бэкенда".
  var ao_guid: Variant[];  --Идентификаторы адресных элементов строка-гуид или отложенный результат.
  var sub_cache: Storage;  --Кэш подчиненных адресных элементов
             -- поле - гуид строкой; значение - массив хранилищ или AsyncResult
  var last_ao_guid             : String;
  var hCache:HouseCache;
  var СтатДомов: Storage[];  --загружаемая при запуске база статусов домов
                             --очень маленькая, поэтому не храним в БД
  var LAGPrefetch: XMLRPC.AsyncResult;

  proc Cache_subs(aoguid:String);
    if aoguid <> nil and not sub_cache.FieldExist(aoguid) then
      sub_cache.SetField(aoguid, ФИАС.GetSubsAsync(aoguid));
    end;
  end;

  func RequestAoGuid: XMLRPC.AsyncResult;
    var n, i, ii: Integer;
    var tmp: Variant;
    var filter_by:Storage;
    ii = LengthofArray(ПрефПолей);
    --вычисление нижнего заполненного уровня
    for i = ii .. 1 step -1 do
        tmp = Record.GetField(ПрефПолей[i] + '_Код');
        if tmp = '' then
           tmp = 0;
        end;
        if Int(tmp)<>0 then
           n = i;
           Break;
        end;
    end;
    filter_by = СборУсл(n + 1); --А вот это не шибко правильно!
    return ФИАС.GetAreasAsync(filter_by,);
  end;


  Func LastAoGuid:String;
    if last_ao_guid = "" then
      LAGfromAreas(RequestAoGuid.Get as Storage[]);
    end;
    return self.last_ao_guid;
  end;


  proc LAGfromAreas(Areas:Variant);
    var tmpa: Storage[];
    var tmp: Storage;
    tmpa = Areas as Storage[];
    tmp = tmpa[1];
    SetLastAoGuid(tmp.aoguid);
  end;


  proc SetLastAoGuid(aoguid:String);
    if LAGPrefetch <> nil then
      LAGPrefetch.abort;
      LAGPrefetch = nil;
    end;

    if aoguid <> '' then
       ФИАС.PollBuildings(aoguid);
    end;
    last_ao_guid = aoguid;
  end;

  Func SaveLevel(AO:Storage):String;
     var prefix:String;
     var l:Integer;
     var filter_by:Storage;
     var AO_:variant[];
        --AO.aolevel = Int(AO.aolevel); --!Фикс для строковой загрузки из REST
        --проверяем - если получено из REST-списка, надо получить объект заново.
        if AO.FieldExist('guid') and not AO.FieldExist('aoguid') then
           --AO.aoguid = AO.guid;
           filter_by = Storage.Create;
           filter_by.aoguid = AO.guid;
           AO_ = ФИАС.GetAreas(filter_by,);
           AO = AO_[1];
        end;
        --Подгрузка потенциально пропущенных полей
--        if not AO.FieldExist('formalname') then
--           AO.formalname = ФИАС.GetAreaProperty(AO.aoguid, 'formalname');
--        end;
--        if not AO.FieldExist('shortname') then
--           AO.shortname = ФИАС.GetAreaProperty(AO.aoguid, 'shortname');
--        end;
--        if not AO.FieldExist('fullname') then
--           AO.fullname = ФИАС.GetAreaProperty(AO.aoguid, 'fullname');
--        end;
        l = SearchInArray(УровниФИАС, AO.aolevel);
        prefix = ПрефПолей[l];
        if l <> 1 then
          Record.SetField(prefix, AO.formalname);
        else
          Record.SetField(prefix + "_Стр", AO.formalname);
        end;
        result = AO.formalname;
        Record.SetField(prefix + "_Код", ФИАС.GetAreaProperty(AO.aoguid, ПоляФИАС[l]));
        ao_guid[l] = AO.aoguid;
        Cache_subs(AO.aoguid);
        if УровниКЛАДР[l] = -1 then
           Record.SetField(prefix + "_Сокр", AO.shortname);
           Record.SetField(prefix + "_Стат", AO.fullname);
        else
           if Lo(prefix) = "наспункт" then
              Record.Пункт_Элемент = ЭлементСтат(AO.shortname, AO.fullname, УровниКЛАДР[l]);
           else
              Record.SetField(prefix + "_Элемент",ЭлементСтат(AO.shortname, AO.fullname, УровниКЛАДР[l]));
           end;
        end;
  end;

  proc UpdGlobal(AO:Storage);
     if AO = nil then
        Код_Кладр = "";
        ОКАТО = "";
        Индекс = "";
        SetLastAoGuid("");
     else
        Код_Кладр = AO.code;
        ОКАТО = AO.okato;
        Индекс = AO.postalcode;
        SetLastAoGuid(AO.aoguid);
     fi;
  end;

  Proc ClearLevel(AOlevel:Integer);
     var prefix:String;
     var l:Integer;
        l = SearchInArray(УровниФИАС, AOlevel);
        prefix = ПрефПолей[l];
        try
            Record.SetField(prefix, "");
        except
            Record.SetField(prefix + "_Стр", "");
        end;
        Record.SetField(prefix + "_Код", "");
        ao_guid[l] = nil;
        if УровниКЛАДР[l] = -1 then
           Record.SetField(prefix + "_Сокр", "");
           Record.SetField(prefix + "_Стат", "");
        else
           if Lo(prefix) = "наспункт" then
              Record.Пункт_Элемент = nil;
           else
              Record.SetField(prefix + "_Элемент",nil);
           end;
        end;
  end;

--------------------------------------------------------------------------------
--{ Обработчики событий бланка
  proc ПоказатьТипыАдресов;
  end;

  proc шаблон_ПриОткрытии(Create :Logical);
    var Mapper: XMLRPC.XMLMapper;
    var FileObj:AutoObject;

    inherited шаблон_ПриОткрытии(Create);
    ТипАдресаНаим               = nil;
    ТипАдресаПрименен           = nil;
    ПоказатьТипыАдресов;
    ФИАС = GetFIASObj;
    hCache = HouseCache.Create;
    sub_cache = Storage.Create;
    Cache_subs('None');  -- Всегда кешируем 'корень'
    --Загрузка справочника статусов домов
    FileObj = AutoObject.Create("Msxml2.DOMDocument.6.0");

    СИС2.Файл.СинхронизироватьФайлы(
      BaseInfo.ProjectByName["АдресК"].Folder + "\\Shared\\AS_ESTSTAT.XML",
      SessionInfo.LocalFolder + "\\AS_ESTSTAT.XML");

    FileObj.load(SessionInfo.LocalFolder + "\\AS_ESTSTAT.XML");
    Mapper = Библио.EstStatMapper;
    СтатДомов = Mapper.ParseNode(FileObj.documentElement).EstateStatus as Storage[];
  end;--proc шаблон_ПриОткрытии


  proc шаблон_ПриСчитывании;
    var k, j: integer;
    var tmpSt: Storage;
    inherited шаблон_ПриСчитывании;
    for k = 1..секПозицииТиповАдресов.Count do
      ТипАдресаПрименен[k] = false;
      for j = 1..Позиции.Count do
        if Позиции.Items[j].ТипАдреса=ТипАдресаНаим[k] then
          ТипАдресаПрименен[k]  = true;
          Break;
        end;
      end;--for j
    end;--for k

    j = LengthOfArray(УровниФИАС);
    for k = 1..j do
        tmpSt = СборУсл(k + 1);
        tmpSt.aolevel = УровниФИАС[k];
        ao_guid[k] = ФИАС.GetAreasAsync(tmpSt, '');
        if k>1 and ao_guid[k] = ao_guid[k-1] then
           ao_guid[k].abort;
           ao_guid[k] = nil;
        else
          --Добавляем постобработку чтобы получать ГУИД из списка
          ao_guid[k].postprocess = XMLRPC.ClassMeth.CreateEx("АдресК.Библио.AGfromAreas");
          --И подвешиваем автоматическое кэширование подчиненных
          ao_guid[k].AutoPoll(self, 'Cache_subs');
        fi;
    end;

    if LAGPrefetch <> nil then
       LAGPrefetch.abort;
    end;

    LAGPrefetch = RequestAoGuid;
    LAGPrefetch.AutoPoll(self, 'LAGfromAreas');
  end;--proc шаблон_ПриСчитывании


  proc Поле_ПриВыходе(Cell :TemplateCell; Index :Integer);
    var j : integer;
    if Cell.Value = false then
      for j = 1..Позиции.Count do
        if Позиции.Items[j].ТипАдреса = ТипАдресаНаим[Index] then
          Позиции.Delete(j);
          Break;
        end;
      end;--for j
    else
      Позиции.Insert(Позиции.Count+1);
      Позиции.Items[Позиции.Count].ТипАдреса = ТипАдресаНаим[Index];
    end;--if Cell.Value
  end;--proc Поле_ПриВыходе

  func СборУсл(l:Integer):Storage;
  --Сбор условия на КЛАДЭ в хранилище для запроса в базу ФИАС
  var res:Storage;
  var i:Integer;
  var tmp:String;
    res = Storage.Create;
    for i = 1..l-1 do
        tmp = Record.GetField(ПрефПолей[i] + '_Код');
        if tmp = nil then
           res.SetField(ПоляФИАС[i], RepStr('0', РазмерКода[i]));
        else
           res.SetField(ПоляФИАС[i], tmp);
        end;
    end;
    Result = res;
  end;

  func SelectFiasAO(ao_list:Storage[]): Variant;
  var i:Integer;
  var ii:Integer;
  var str_list:String[];
  var one:Storage;
    ii = LengthOfArray(ao_list);
    if ii = 0 then
      Message("Не найдено адресных элементов");
      return False;
    end;
    for i = 1..ii do
        one = ao_list[i] as Storage;
        str_list[i] = one.name;
    end;
    i = Alternate("Выбор элемента адресации",str_list);
    if i <> 0 then
       Result = ao_list[i];
    else
       Result = false;
    end;
  end;

  proc FIAS_check(l:Integer);
  --@doc Пост-обработка для выбора уровня: пустые коды предшественников устанавливаются в нули,
  --     низлежащие уровни обнуляются
  var i:Integer;
        for i = 1 .. l - 1 do
            if Record.GetField(ПрефПолей[i] + '_Код') = nil then
                Record.SetField(ПрефПолей[i] + "_Код", RepStr('0', РазмерКода[i]));
            end;
        end;
        for i = l + 1 .. LengthOfArray(УровниФИАС) do
            ClearLevel(УровниФИАС[i]);
        end;

  end;

  func Поле_СтрПриОбзоре(Cell :TemplateCell; Value :Variant;
                               var NewValue :Variant) :Logical;
    -- Обработка события нажатия у клетки кнопки обзора
    -- Параметры:
    --   Cell: клетка шаблона
    --   Value: старое значение в поле. Его тип зависит от типа поля.
    --   NewValue: новое значение в поле. Его тип зависит от типа поля.
    var filter_by:Storage;
    var l: Integer;
    var i, ii: Integer;
    var tmp:Variant;
    var tmpGuid:String;
    l = SearchInArray(ПрефПолей, ExtractWord(Cell.Contents, 1, "_"));
    tmp = nil;
    --Надо найти предыдущий ненулевой элемент
    ii = l;
    tmpGuid = '';
    for i = (ii - 1) .. 1 step -1 do
       if ao_guid[i] <> nil:
         if ao_guid[i] is XMLRPC.AsyncResult:
            ao_guid[i] = ao_guid[i].Get;
         fi;
         tmpGuid = ao_guid[i];
         Break;
       fi;
    end;
    if tmpGuid = '' then
       tmpGuid = 'None';
    end;
    --!!!
    --Если есть закэшированный список - выведем его
    if tmpGuid <> nil and sub_cache.FieldExists(tmpGuid):
       if sub_cache.GetField(tmpGuid) is XMLRPC.AsyncResult then
          if sub_cache.GetField(tmpGuid).ready then
             tmp = sub_cache.GetField(tmpGuid).Get;
             --Ну и сохраним заодно чтобы не парсить заново
             sub_cache.SetField(tmpGuid, tmp);
          end;
       else  --уже распарсен
         tmp = sub_cache.GetField(tmpGuid);
       end;
       if tmp is Storage and tmp.FieldExist('sub') then
          tmp = tmp.sub;
        --!!!Доппроверка too_much
       end;
       if varType(tmp) = 8 then  --Тут еще может быть строка с ошибкой
          tmp = XMLRPC.Библио.Filter('aolevel = "'+Str(УровниФИАС[l])+'"', tmp as Object[]);
       end;
    end;

    if tmp = nil then
      --Если с кэшем не срослось - запрашиваем из базы
      filter_by = СборУсл(l);
      filter_by.aolevel = УровниФИАС[l];
      tmp = ФИАС.GetAreas(filter_by,);
    end;
    if VarType(tmp) = varString  then
       Message(tmp);
       return False;
    else
       tmp = SelectFiasAO(tmp as Storage[]);
       if tmp = False then
          return False;
       else
          tmp = tmp as Storage;
          Template.endEdit(False);
          NewValue = SaveLevel(tmp);
          UpdGlobal(tmp);
          FIAS_check(l);
       end;
    end;
    Result = False;
  end;

  func Поле_СтрПриПроверке(Cell :TemplateCell; Index :Integer;
                                 var Value :Variant) :Logical;
    -- Проверка введенного значеия
    -- Параметры:
    --   Cell: клетка шаблона
    --   Index: номер кадра, в котором находится клетка
    --   Value: значение, которое нужно проверить
    var filter_by:Storage;
    var l: Integer;
    var tmp:Variant;
    var tmpa:Storage[];
    l = SearchInArray(ПрефПолей, ExtractWord(Cell.Contents, 1, "_"));
    if Value = "" then   --Delete
       FIAS_check(l-1);
       UpdGlobal(nil);
       return True;  --Ручной ввод
    end;
    filter_by = СборУсл(l);
    filter_by.aolevel = УровниФИАС[l];
    tmp = ФИАС.GetAreas(filter_by,'%'+Value+'%');--SimpleCall("http://127.0.0.1:8080/","GetAreas",[filter_by])[1];
    if VarType(tmp) = varString  then
       Message(tmp);
       return False;
    else
       tmpa = tmp as Storage[];
       if LengthOfArray(tmpa) = 0 then
          FIAS_check(l-1); -- -1 чтобы обнулить свой уровень
          UpdGlobal(nil);
          return True;  --Ручной ввод
       elsif LengthOfArray(tmpa) = 1 then
          tmp = tmpa[1];
       else
          tmp = SelectFiasAO(tmpa);
       end;
       if tmp = False then
          FIAS_check(l);
          UpdGlobal(nil);
          return True;  --Ручной ввод
       else
          tmp = tmp as Storage;
          Value = SaveLevel(tmp);
          UpdGlobal(tmp);
          FIAS_check(l);
       end;
    end;
    Result = True; -- Разрешаем сохранить изменения в поле
  end;

--    func ПолеДом_стрПриОбзоре(Cell :TemplateCell; Value :Variant;
--                            var NewValue :Variant) :Logical;
--    -- Обработка события нажатия у клетки кнопки обзора
--    -- Параметры:
--    --   Cell: клетка шаблона
--    --   Value: старое значение в поле. Его тип зависит от типа поля.
--    --   NewValue: новое значение в поле. Его тип зависит от типа поля.
--    var l: Integer;
--    var filter_by:Storage;
--    var tmp:Variant;
--    var tmpa:Storage[];
--    var i:Integer;
--    var ii:Integer;
--    var str_list:String[];
--    var one:Storage;


----    var eLeft:Real;
----    var eTop:Real;
----    var eWidth:Real;
----    var eHeight:Real;
----    var cbox:ComboBox;

----    eLeft = Cell.Owner.Column[Cell.Column].Left;
----    eWidth = Cell.Owner.Column[Cell.Column].Width;
----    eTop = Cell.Owner.Row[Cell.Row].Top;
----    eHeight = Cell.Owner.Row[Cell.Row].Height;
----    Trace([eLeft,eWidth,eTop,eHeight]);
----    cbox = Template.Currentframe.AddObject(ComboBox);
----    cbox.Left = eLeft;
----    cbox.Top = eTop;
----    cbox.Width = eWidth;
----    cbox.Height = eHeight;
----    Template.endEdit(False);
----    cbox.Setfocus;
----    Template.BeginEdit;

----    i = Alternate("Выбор региона",str_list);
----    if i <> 0 then
----       tmp = tmpa[i];
----       Дом_Стр = tmp.onestr;
----       Result = false; -- Продолжаем стандартную обработку
----    else
----       Result = false;
----    end;
--  end;

  func ПолеДом_стрПриВходе(Cell :TemplateCell; Index :Integer;
                           Action :Template.EnterTypes) :Logical;
    -- Параметры:
    --   Cell: клетка шаблона
    --   Index: номер кадра, в котором находится клетка
    --   Action: тип входа (Вход,Вставка,Очистка)
    var pairs:String[2];
    var i:Integer;
    var ii:Integer;
    pairs = hCache.gethouses(LastAoGuid);
    ii = LengthOfArray(pairs[1]);
    Cell.List.Clear;
    for i = 1..ii do
        Cell.List.Add(pairs[1, i] + "|");
    end;
    Cell.List.Sort;
    Result = True; -- Разрешаем войти в поле
  end;

  proc ПолеДом_стрПриВыходе(Cell :TemplateCell; Index :Integer);
    -- Обработка события выхода из редактируемого поля
    -- Параметры:
    --   Cell: клетка шаблона
    --   Index: номер кадра, в котором находится клетка
    var reqpar:String[];
    var tmp:Storage;
    var pairs:String[2];
    var i, j:Integer;
    reqpar = ['housenum', 'strucnum', 'buildnum', 'eststatus'];
    InsertInArray(reqpar, 1, 'postalcode');
    InsertInArray(reqpar, 1, 'okato');

    pairs = hCache.gethouses(LastAoGuid);

    i = SearchInArray(pairs[1], Cell.Value);
    if i>0 then
      tmp = ФИАС.GetBuildingProperties(pairs[2, i], reqpar);
      Record.Дом_Н = tmp.housenum;
      Record.Дом_К = tmp.buildnum;
      Record.Дом_С = tmp.strucnum;
      Record.Индекс = tmp.postalcode;
      Record.ОКАТО = tmp.okato;
      --тип дома
      for j = 1 .. LengthOfArray(СтатДомов) do
        if СтатДомов[j].ESTSTATID = Int(tmp.eststatus) then
           Дом_Элемент = ЭлементСтат(СтатДомов[j].NAME,СтатДомов[j].NAME,6);
        end;
      end;
      --Поля для совместимости
      Record.Корпус = Record.Дом_К;
      Record.Дом = Record.Дом_Н;
      if Record.Дом_С <> nil then
         if Record.Корпус = nil then
            Record.Дом = Record.Дом + ' c.' + Record.Дом_С;
         else
            Record.Корпус = Record.Корпус + ' c.' + Record.Дом_С;
         end;
      end;
    end;
  end;

  func АвтоАдрес_Общее_ПриНажатии(Cell :TemplateCell; Action :Template.ClickTypes)
                                  :Logical;
    -- Обработка события нажатия в зависимости от типа
    -- Параметры:
    --   Cell: клетка шаблона
    --   Action: тип нажатия (SingleClick, DoubleClick, EnterPressed, ButtonPressed)
    Адрес_Строкой = Базовый.Справочники.интАдрес.Адрес_Общий(Record);
    Result = True; -- Разрешаем стандартную обработку
  end;

--}

end